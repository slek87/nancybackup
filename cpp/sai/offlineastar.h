#pragma once
#include <unordered_map>
#include <functional>
#include "../utility/PriorityQueue.h"
#include"../utility/ResultContainer.h"


using namespace std;

template <class Domain>
class OfflineAStar {
public:
    typedef typename Domain::State State;
	typedef typename Domain::Cost Cost;
    typedef typename Domain::HashState Hash;

    struct Node	{
		Cost g;
		Cost h;
		Cost d;
		Cost derr;
		Cost epsH;
		Cost epsD;
		Node* parent;
		State stateRep;
		int owningTLA;
		bool open;
		int delayCntr;
		// DiscreteDistribution distribution;

	public:
		Cost getGValue() const { return g; }
		Cost getHValue() const { return h; }
		Cost getDValue() const { return d; }
		Cost getDErrValue() const { return derr; }
		Cost getFValue() const { return g + h; }
		Cost getEpsilonH() const { return epsH; }
		Cost getEpsilonD() const { return epsD; }
		Cost getFHatValue() const { return g + getHHatValue(); }
		Cost getDHatValue() const { return (derr / (1.0 - epsD)); }
		Cost getHHatValue() const { return h + getDHatValue() * epsH; }
		State getState() const { return stateRep; }
		Node* getParent() const { return parent; }
		int getOwningTLA() const { return owningTLA; }

		void setHValue(Cost val) { h = val; }
		void setGValue(Cost val) { g = val; }
		void setDValue(Cost val) { d = val; }
		void setDErrValue(Cost val) { derr = val; }
		void setEpsilonH(Cost val) { epsH = val; }
		void setEpsilonD(Cost val) { epsD = val; }
		void setState(State s) { stateRep = s; }
		void setOwningTLA(int tla) { owningTLA = tla; }
		void setParent(Node* p) { parent = p; }

		bool onOpen() { return open; }
		void close() { open = false; }
		void reOpen() { open = true; }

		void incDelayCntr() { delayCntr++; }
		int getDelayCntr() { return delayCntr; }

		void markStart() { stateRep.markStart(); }

		Node(Cost g, Cost h, Cost d, Cost derr, Cost epsH, Cost epsD, State state, Node* parent, int tla)
			: g(g), h(h), d(d), derr(derr), epsH(epsH), epsD(epsD), stateRep(state), parent(parent), owningTLA(tla)
		{
			open = true;
			delayCntr = 0;
		}

		friend std::ostream& operator<<(std::ostream& stream, const Node& node) {
			stream << node.getState() << endl;
			stream << "f: " << node.getFValue() << endl;
			stream << "g: " << node.getGValue() << endl;
			stream << "h: " << node.getHValue() << endl;
			stream << "derr: " << node.getDErrValue() << endl;
			stream << "d: " << node.getDValue() << endl;
			stream << "epsilon-h: " << node.getEpsilonH() << endl;
			stream << "epsilon-d: " << node.getEpsilonD() << endl;
			stream << "f-hat: " << node.getFHatValue() << endl;
			stream << "d-hat: " << node.getDHatValue() << endl;
			stream << "h-hat: " << node.getHHatValue() << endl;
			stream << "action generated by: " << node.getState().getLabel() << endl;
			stream << "-----------------------------------------------" << endl;
			stream << endl;
			return stream;
		}

		static bool compareNodesF(const Node* n1, const Node* n2)
		{
			// Tie break on g-value
			if (n1->getFValue() == n2->getFValue())
			{
				return n1->getGValue() > n2->getGValue();
			}
			return n1->getFValue() < n2->getFValue();
		}

		static bool compareNodesFHat(const Node* n1, const Node* n2)
		{
			// Tie break on g-value
			if (n1->getFHatValue() == n2->getFHatValue())
			{
				return n1->getGValue() > n2->getGValue();
			}
			return n1->getFHatValue() < n2->getFHatValue();
		}

		static bool compareNodesH(const Node* n1, const Node* n2)
		{
			if (n1->getHValue() == n2->getHValue())
			{
				return n1->getGValue() > n2->getGValue();
			}
			return n1->getHValue() < n2->getHValue();
		}
	};

    OfflineAStar(Domain& domain) : domain(domain) {}

    ResultContainer solve(){
        ResultContainer res;
        PriorityQueue<Node*> open;
        unordered_map<State, Node*, Hash> closed;

        Node* start = new Node(0, domain.heuristic(domain.getStartState()), domain.distance(domain.getStartState()),
			domain.distanceErr(domain.getStartState()), domain.epsilonHGlobal(), domain.epsilonDGlobal(),
			domain.getStartState(), NULL, -1);
        open.swapComparator(Node::compareNodesF);
        open.push(start);


        while (!open.empty()){
			Node* cur = open.top();


            if (domain.isGoal(cur->getState()))
			{
                return res;
			}

			res.nodesExpanded++;

			open.pop();
			cur->close();
			vector<State> children = domain.successors(cur->getState());
			res.nodesGenerated += children.size();

			for (State child : children){
				Node* childNode = new Node(cur->getGValue() + domain.getEdgeCost(child),
					domain.heuristic(child), domain.distance(child), domain.distanceErr(child), 
					domain.epsilonHGlobal(), domain.epsilonDGlobal(), child, cur, cur->getOwningTLA());
				bool dup = duplicateDetection(childNode, closed, open);


				// Duplicate detection
				if (!dup)
				{
					open.push(childNode);
					closed[child] = childNode;
				}
				else
					delete childNode;
			}

        }
    }

private:
	static bool duplicateDetection(Node* node, unordered_map<State, Node*, Hash>& closed, PriorityQueue<Node*>& open)
	{
		// Check if this state exists 
		typename unordered_map<State, Node*, Hash>::iterator it = closed.find(node->getState());

		if (it != closed.end())
		{
			// This state has been generated before, check if its node is on OPEN
			if (it->second->onOpen())
			{
				// This node is on OPEN, keep the better g-value
				if (node->getGValue() < it->second->getGValue())
				{
					it->second->setGValue(node->getGValue());
					it->second->setParent(node->getParent());
					it->second->setHValue(node->getHValue());
					it->second->setDValue(node->getDValue());
					it->second->setDErrValue(node->getDErrValue());
					it->second->setEpsilonH(node->getEpsilonH());
					it->second->setEpsilonD(node->getEpsilonD());
					it->second->setState(node->getState());
					it->second->setOwningTLA(node->getOwningTLA());
				}
			}
			else
			{
				// This node is on CLOSED, compare the f-values. If this new f-value is better, reset g, h, and d. 
				// Then reopen the node.
				if (node->getFValue() < it->second->getFValue())
				{
					it->second->setGValue(node->getGValue());
					it->second->setParent(node->getParent());
					it->second->setHValue(node->getHValue());
					it->second->setDValue(node->getDValue());
					it->second->setDErrValue(node->getDErrValue());
					it->second->setEpsilonH(node->getEpsilonH());
					it->second->setEpsilonD(node->getEpsilonD());
					it->second->setState(node->getState());
					it->second->setOwningTLA(node->getOwningTLA());
					it->second->reOpen();
					open.push(it->second);
				}
			}

			return true;
		}

		return false;
	}


protected:
	Domain & domain;
};